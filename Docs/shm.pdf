%PDF-1.4
%“Œ‹ž ReportLab Generated PDF document http://www.reportlab.com
1 0 obj
<< /F1 2 0 R /F2 3 0 R /F3 4 0 R /F4 5 0 R >>
endobj
2 0 obj
<< /BaseFont /Helvetica /Encoding /WinAnsiEncoding /Name /F1 /Subtype /Type1 /Type /Font >>
endobj
3 0 obj
<< /BaseFont /Helvetica-Bold /Encoding /WinAnsiEncoding /Name /F2 /Subtype /Type1 /Type /Font >>
endobj
4 0 obj
<< /BaseFont /Helvetica-Oblique /Encoding /WinAnsiEncoding /Name /F3 /Subtype /Type1 /Type /Font >>
endobj
5 0 obj
<< /BaseFont /Courier /Encoding /WinAnsiEncoding /Name /F4 /Subtype /Type1 /Type /Font >>
endobj
6 0 obj
<< /Contents 31 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
7 0 obj
<< /Contents 32 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
8 0 obj
<< /Contents 33 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
9 0 obj
<< /Contents 34 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
10 0 obj
<< /Contents 35 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
11 0 obj
<< /Contents 36 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
12 0 obj
<< /Contents 37 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
13 0 obj
<< /Contents 38 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
14 0 obj
<< /Contents 39 0 R /MediaBox [ 0 0 595.2756 841.8898 ] /Parent 30 0 R /Resources << /Font 1 0 R /ProcSet [ /PDF /Text /ImageB /ImageC /ImageI ] >> /Rotate 0 /Trans <<  >> 
  /Type /Page >>
endobj
15 0 obj
<< /Outlines 17 0 R /PageLabels 40 0 R /PageMode /UseNone /Pages 30 0 R /Type /Catalog >>
endobj
16 0 obj
<< /Author () /CreationDate (D:20151001074920+07'00') /Creator (\(unspecified\)) /Keywords () /Producer (ReportLab PDF Library - www.reportlab.com) /Subject (\(unspecified\)) 
  /Title (C++ Cross-Process Shared Memory Tools) >>
endobj
17 0 obj
<< /Count 15 /First 18 0 R /Last 28 0 R /Type /Outlines >>
endobj
18 0 obj
<< /Dest [ 6 0 R /XYZ 62.69291 665.0236 0 ] /Next 19 0 R /Parent 17 0 R /Title (Reminder) >>
endobj
19 0 obj
<< /Count 4 /Dest [ 6 0 R /XYZ 62.69291 309.6236 0 ] /First 20 0 R /Last 23 0 R /Next 24 0 R /Parent 17 0 R 
  /Prev 18 0 R /Title (SHMMain, ServerSide and ClientSide) >>
endobj
20 0 obj
<< /Dest [ 6 0 R /XYZ 62.69291 213.4236 0 ] /Next 21 0 R /Parent 19 0 R /Title (SHMMain) >>
endobj
21 0 obj
<< /Dest [ 7 0 R /XYZ 62.69291 258.6236 0 ] /Next 22 0 R /Parent 19 0 R /Prev 20 0 R /Title (ServerSide) >>
endobj
22 0 obj
<< /Dest [ 8 0 R /XYZ 62.69291 210.6236 0 ] /Next 23 0 R /Parent 19 0 R /Prev 21 0 R /Title (ClientSide) >>
endobj
23 0 obj
<< /Dest [ 9 0 R /XYZ 62.69291 269.8236 0 ] /Parent 19 0 R /Prev 22 0 R /Title (Middleside) >>
endobj
24 0 obj
<< /Count 3 /Dest [ 10 0 R /XYZ 62.69291 551.8236 0 ] /First 25 0 R /Last 27 0 R /Next 28 0 R /Parent 17 0 R 
  /Prev 19 0 R /Title (Complex Interactions) >>
endobj
25 0 obj
<< /Dest [ 11 0 R /XYZ 62.69291 408.6236 0 ] /Next 26 0 R /Parent 24 0 R /Title (Address Randomization) >>
endobj
26 0 obj
<< /Dest [ 12 0 R /XYZ 62.69291 510.6236 0 ] /Next 27 0 R /Parent 24 0 R /Prev 25 0 R /Title (Examples) >>
endobj
27 0 obj
<< /Dest [ 12 0 R /XYZ 62.69291 141.0236 0 ] /Parent 24 0 R /Prev 26 0 R /Title (Five Biggest Headaches) >>
endobj
28 0 obj
<< /Count 1 /Dest [ 14 0 R /XYZ 62.69291 503.8236 0 ] /First 29 0 R /Last 29 0 R /Parent 17 0 R /Prev 24 0 R 
  /Title (Conclusion) >>
endobj
29 0 obj
<< /Dest [ 14 0 R /XYZ 62.69291 452.8236 0 ] /Parent 28 0 R /Title (Known Bugs:) >>
endobj
30 0 obj
<< /Count 9 /Kids [ 6 0 R 7 0 R 8 0 R 9 0 R 10 0 R 11 0 R 12 0 R 13 0 R 14 0 R ] /Type /Pages >>
endobj
31 0 obj
<< /Length 5354 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 741.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 4 Tm /F2 20 Tf 24 TL 35.43488 0 Td (C++ Cross-Process Shared Memory Tools) Tj T* -35.43488 0 Td ET
Q
Q
q
1 0 0 1 62.69291 719.0236 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (The C++ Cross-Process Shared Memory Tools is new In PicklingTools 1.4.0.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 677.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 1.329269 Tw (Although the PicklingTools library has had tools to handle cross process shared memory for sometime) Tj T* 0 Tw .388651 Tw (\(since 1.0.0\), this release introduces some simple abstractions to help make using shared memory a little) Tj T* 0 Tw (bit easier.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 644.0236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Reminder) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 602.0236 cm
q
BT 1 0 0 1 0 26 Tm .964692 Tw 12 TL /F1 10 Tf 0 0 0 rg (First, a quick reminder: C++ Vals ) Tj /F3 10 Tf (can ) Tj /F1 10 Tf (be used with shared memory: this is the reason the ) Tj /F4 10 Tf 0 0 0 rg (Allocator) Tj T* 0 Tw .413876 Tw /F1 10 Tf 0 0 0 rg (became an inherent part of the PicklingTools back in 1.0.0. For example, to create a Tab in some shared) Tj T* 0 Tw (memory region:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 532.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 60 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F4 10 Tf 12 TL (char* mem = ... create/attach shared memory across processes ...) Tj T* (StreamingPool *shm=StreamingPool::CreateStreamingPool\(mem, bytes, 8\);) Tj T* (Val v = Shared\(shm, Tab\(\)\);) Tj T* (v["a"] = "hello";   // Table and keys and values in shared memory) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 488.8236 cm
q
BT 1 0 0 1 0 26 Tm .500651 Tw 12 TL /F1 10 Tf 0 0 0 rg (The shared memory can be created with ) Tj /F4 10 Tf 0 0 0 rg (SHMCreate ) Tj /F1 10 Tf 0 0 0 rg (or connected to with already created memory with) Tj T* 0 Tw 1.760574 Tw /F4 10 Tf 0 0 0 rg (SHMAttach) Tj /F1 10 Tf 0 0 0 rg (, but it's tricky to get this right with the basic tools provided by the simple abstractions in) Tj T* 0 Tw ("sharedmemory.h":) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 407.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 50 Tm /F4 10 Tf 12 TL (size_t bytes = 1024*1024;) Tj T* (char* mem = SHMCreate\("shm_region", bytes\);) Tj T* (// Created, but is it available yet?  Do you have to check) Tj T* (// if the entire shared memory has been mapped into the process) Tj T* (// with SHMInitialized, etc.) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 351.6236 cm
q
BT 1 0 0 1 0 38 Tm .964104 Tw 12 TL /F1 10 Tf 0 0 0 rg (The process for using shared memory is a little clumsy: Who creates and who attaches? The creator is) Tj T* 0 Tw .27229 Tw (responsible for calling ) Tj /F4 10 Tf 0 0 0 rg (SHMInitialize ) Tj /F1 10 Tf 0 0 0 rg (and the user is responsible for called ) Tj /F4 10 Tf 0 0 0 rg (SHMInitialized ) Tj /F1 10 Tf 0 0 0 rg (to see) Tj T* 0 Tw .225444 Tw (if the region is ready, even it already mapped it. But these have to done in the right order, and it's not well) Tj T* 0 Tw (documented.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 321.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .88311 Tw (To address these concerns, there are three new abstractions that handle Vals in shared memory a little) Tj T* 0 Tw (better.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 288.6236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (SHMMain, ServerSide and ClientSide) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 258.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.499984 Tw (There are three new classes that make using shared memory a lot easier: SHMMain, ServerSide and) Tj T* 0 Tw (ClientSide. These all come from:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 225.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (#include "shmboot.h"   // Gets defn of SHMMain, ClientSide and ServerSide) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 195.4236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (SHMMain) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 165.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .363735 Tw (SHMMain is responsible for creating the shared memory region of the proper size that all ServerSide and) Tj T* 0 Tw (ClientSides can use. And that's it. It needs to be called exactly once.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 135.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .431235 Tw (Ideally, the SHMMain gets called exactly once in a startup process that gets called before everyone else:) Tj T* 0 Tw (frequently at the start of some main process that has to be started before anything else in the app:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 78.22362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 48 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F4 10 Tf 12 TL (#include "shmboot.h") Tj T*  T* (int main \(int argc, char**argv\)) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
32 0 obj
<< /Length 5181 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 619.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 144 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 122 Tm /F4 10 Tf 12 TL ({) Tj T* (   int bytes = atoi\(argv[1]\);) Tj T*  T* (   // Initial set-up code) Tj T* (   bool debug = true;) Tj T* (   SHMMain mem\("shm_region", bytes, debug\);) Tj T* (   mem.start\(\);  // Actually calls and creates region) Tj T*  T* (   ... start rest of application, fork processes, etc. ...) Tj T*  T* (}) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 563.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL 1.906412 Tw (Sometimes, if an application is built piecewise, the model described above won't quite work: imagine) Tj T* 0 Tw .203984 Tw (something similar to a UNIX pipeline where each process may be communicating piecewise to server and) Tj T* 0 Tw 1.016488 Tw (a client. In a case like that, the "head" of the pipeline would be where the SHMMain should have to be) Tj T* 0 Tw (created.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 509.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL 1.841318 Tw (Once the SHMMain is created \(and started\), this establishes a shared memory zone or "pool" where) Tj T* 0 Tw .127882 Tw (queues and Vals can be used. Note that the SHMMain can be created from any process, even if there are) Tj T* 0 Tw .627356 Tw (no servers or clients in it: its sole purpose is to create and establish the shared memory region that later) Tj T* 0 Tw (ServerSides and ClientSides use.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 407.8236 cm
q
BT 1 0 0 1 0 86 Tm .27683 Tw 12 TL /F1 10 Tf 0 0 0 rg (Expert Notes: If you are creating a system where the clients and servers all are all created from one main) Tj T* 0 Tw 1.839985 Tw (process, then that makes things easier: you don't ) Tj /F3 10 Tf (have ) Tj /F1 10 Tf (to specify a region, as all clients/servers that) Tj T* 0 Tw 1.926235 Tw (inherit from the main process can use the region already mapped in the main process: assuming all) Tj T* 0 Tw .219318 Tw (clients/servers ) Tj /F4 10 Tf 0 0 0 rg (fork ) Tj /F1 10 Tf 0 0 0 rg (from the main above and don't ) Tj /F4 10 Tf 0 0 0 rg (exec) Tj /F1 10 Tf 0 0 0 rg (, the shared memory set-up from SHMMain will) Tj T* 0 Tw .116179 Tw (be inherited \(in a process sense, not in a OOP sense\) and be in the same address space in all the clients.) Tj T* 0 Tw 2.537318 Tw (However, if \(like all the examples in the baseline\), the clients and servers are completely separate) Tj T* 0 Tw .129461 Tw (processes, they HAVE to be mapped to the same area: in this case, you want to specify where in memory) Tj T* 0 Tw (to map:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 326.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 50 Tm /F4 10 Tf 12 TL (// On a 32-bit i386 Linux machine, force into a pretty unused area) Tj T* (SHMMain mem\("shm_region_32bit", bytes, debug, \(void*\)0xB0000000\);) Tj T*  T* (// On a 64-bit x86_64 Linux machine, force into pretty unused area) Tj T* (SHMMain mem\("shm_region_64bit", bytes, debug, \(void*\)0x700000000000ULL\);) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 270.6236 cm
q
BT 1 0 0 1 0 38 Tm 1.497984 Tw 12 TL /F1 10 Tf 0 0 0 rg (Although the small standalone programs tend to work without forcing to use a particular region, larger) Tj T* 0 Tw .15936 Tw ("real" applications tend to need to be forced. Although the ServerSide and ClientSide ) Tj /F3 10 Tf (can ) Tj /F1 10 Tf (explicitly set the) Tj T* 0 Tw .123488 Tw (memory needed, usually you only want to do this in the SHMMain \(which sets it up in the right region\) and) Tj T* 0 Tw (that forces all clients and servers to attach to the right region.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 240.6236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (ServerSide) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 198.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .07881 Tw (The ServerSide presents the abstraction of a server, although strictly speaking it can also be either side of) Tj T* 0 Tw .849985 Tw (a communication. The most important thing a ServerSide does is to create the pipe \(in shared memory\)) Tj T* 0 Tw (which will be used for queuing and enqueueing.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 168.6236 cm
q
BT 1 0 0 1 0 14 Tm 1.72683 Tw 12 TL /F1 10 Tf 0 0 0 rg (To create a pipe, you have to give it a string name \(in the example below, ) Tj /F4 10 Tf 0 0 0 rg (pipename) Tj /F1 10 Tf 0 0 0 rg (\) and start the) Tj T* 0 Tw (ServerSide:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 87.42362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (// Create a pipe in the shared memory region \(string name used in SHMMain\)) Tj T* (// The pipe has the given capacity \(capacity is in packets\).) Tj T* (bool debug = true;) Tj T* (int packet_capacity = 4;) Tj T* (ServerSide server\("shm_region",) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
33 0 obj
<< /Length 4520 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 703.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 60 re B*
Q
q
BT 1 0 0 1 0 38 Tm 12 TL /F4 10 Tf 0 0 0 rg (                  "pipename", packet_capacity. true\);) Tj T*  T* (server.start\(\);   // pipe only created when started) Tj T* (CQ) Tj (&) Tj ( pipe = server.pipe\(\);) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 647.8236 cm
q
BT 1 0 0 1 0 38 Tm 2.85811 Tw 12 TL /F1 10 Tf 0 0 0 rg (Once the pipe has been created, it can be enqueued or dequeued from: ) Tj /F3 10 Tf (Note that queueing and) Tj T* 0 Tw .74229 Tw (dequeueing is thread-safe) Tj /F1 10 Tf (: I.e., you can have multiple processes operating on the queue simultaneously) Tj T* 0 Tw .41284 Tw (and its state is never inconsistent. Typically, the ServerSide enqueues and the ClientSide dequeues from) Tj T* 0 Tw (the given CQ:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 362.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 474 276 re B*
Q
q
BT 1 0 0 1 0 254 Tm 12 TL /F4 10 Tf 0 0 0 rg (// ServerSide enqueues) Tj T* (for \(int seq=0; ; seq++\) {) Tj T*  T* (   // Create the value to enqueue in shared memory) Tj T* (   Val data = Shared\(server.pool\(\), Tab\(\)\);  // Create a Tab in shared memory) Tj T* (   data["sequence_number"] = seq;) Tj T*  T* (   // Now enqueue) Tj T* (   bool enqueued = false;) Tj T* (   real_8 timeout_in_seconds = 3.2;) Tj T* (   while \(!enqueued\) {) Tj T* (       enqueued = pipe.enqueue\(data, timeout_in_seconds\);) Tj T* (       if \(!enqueued\) {) Tj T* (           cerr ) Tj (<) Tj (<) Tj ( "Failed to enqueue after " ) Tj (<) Tj (<) Tj ( timeout_in_seconds) Tj T* (                ) Tj (<) Tj (<) Tj ( " in seconds ... trying again ..." ) Tj (<) Tj (<) Tj ( endl;) Tj T* (       } else {) Tj T* (           cout ) Tj (<) Tj (<) Tj ( "Enqueued! Going to next packet" ) Tj (<) Tj (<) Tj ( endl;) Tj T* (           break;) Tj T* (       }) Tj T* (   }) Tj T*  T* (}) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 294.6236 cm
q
BT 1 0 0 1 0 50 Tm .29908 Tw 12 TL /F1 10 Tf 0 0 0 rg (Note that the enqueue has a timeout: in case the queue is full and the Val can't be placed in the queue, it) Tj T* 0 Tw 1.119431 Tw (will wait up to ) Tj /F4 10 Tf 0 0 0 rg (timeout_in_seconds ) Tj /F1 10 Tf 0 0 0 rg (for some space to open up. If the space opens up in the given) Tj T* 0 Tw .451751 Tw (time, the data is enqueued and enqueue returns true: the data has now been enqueued. If space doesn't) Tj T* 0 Tw 1.743516 Tw (open up in the given time, enqueue returns false. In the example code above, the sender just keeps) Tj T* 0 Tw (retrying, but gives a warning every 3.2 seconds warning indicating the queue is full.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 252.6236 cm
q
BT 1 0 0 1 0 26 Tm 1.059985 Tw 12 TL /F1 10 Tf 0 0 0 rg (Although typically the ServerSide is used as the ) Tj /F3 10 Tf (send ) Tj /F1 10 Tf (side only, there's no reason the ServerSide can't) Tj T* 0 Tw 1.092765 Tw (dequeue as well \(see below for examples of how to dequeue\). This ability might be useul if that queue) Tj T* 0 Tw (needed to be cleaned as part of a shutdown or restart.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 222.6236 cm
q
BT 1 0 0 1 0 14 Tm .436235 Tw 12 TL /F1 10 Tf 0 0 0 rg (There is another call to enqueue data ) Tj /F4 10 Tf 0 0 0 rg (pipe.enq\(data\) ) Tj /F1 10 Tf 0 0 0 rg (which will block forever; this is simpler and will) Tj T* 0 Tw (work but makes it harder to detect error conditions and/or gracefully exit.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 192.6236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (ClientSide) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 162.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.037988 Tw (The ClientSide is the other end of the pipe: if the ServerSide creates the pipe and writes to it, then the) Tj T* 0 Tw (ClientSide waits for the pipe to be created so it can attach and read from the pipe:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 81.42362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg ( ClientSide client\("shm_region", "pipename", true\);) Tj T* ( client.start\(\); // blocks waiting for pipe to be created) Tj T*  T* ( CQ) Tj (&) Tj ( pipe = client.pipe\(\);) Tj T*  T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
34 0 obj
<< /Length 4442 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 499.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 264 re B*
Q
q
BT 1 0 0 1 0 242 Tm 12 TL /F4 10 Tf 0 0 0 rg ( // Once pipe is available, we can read from it) Tj T* ( real_8 timeout_in_seconds = 5.5;) Tj T* ( while \(1\) {) Tj T*  T* (   // Try to dequeue a single packet) Tj T* (   Val packet;) Tj T* (   bool valid=false;) Tj T* (   while \(!valid\) {) Tj T*  T* (       valid = pipe.dequeue\(timeout_in_seconds, packet\);) Tj T* (       if \(!valid\) {) Tj T* (             cerr ) Tj (<) Tj (<) Tj ( "Couldn't dequeue after " ) Tj (<) Tj (<) Tj ( timeout_in_seconds) Tj T* (                  ) Tj (<) Tj (<) Tj ( " ... trying to dequeue again ... " ) Tj (<) Tj (<) Tj ( endl;) Tj T* (             continue;) Tj T* (       } else {) Tj T* (             cout ) Tj (<) Tj (<) Tj ( "Got packet!" ) Tj (<) Tj (<) Tj ( endl;) Tj T* (             break;) Tj T* (       }) Tj T*  T* (   }) Tj T* (}) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 467.8236 cm
q
BT 1 0 0 1 0 14 Tm 1.427488 Tw 12 TL /F1 10 Tf 0 0 0 rg (Note that the client \(in order to read from the proper pipe\) has to match ) Tj /F3 10 Tf (both ) Tj /F1 10 Tf (the name of the shared) Tj T* 0 Tw (memory region ) Tj /F3 10 Tf (and ) Tj /F1 10 Tf (the pipename the server writes to.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 413.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL .782927 Tw (In the above example, if the client can't get something from the pipe immediately, thee queue blocks for) Tj T* 0 Tw .997209 Tw (up to a few seconds. If something appears on the pipe before the timeout, then that value is dequeued) Tj T* 0 Tw 1.385777 Tw (and taken off the pipe and valid becomes true. If after those few seconds the pipe is still empty, valid) Tj T* 0 Tw (becomes false and the dequeue fails.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 383.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.092651 Tw (This is basic paradigm: Use SHMMain to create the shared memory region before anything else starts,) Tj T* 0 Tw (start and create a sender with a ServerSide and client with ClientSide.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 281.8236 cm
q
BT 1 0 0 1 0 86 Tm .50311 Tw 12 TL /F1 10 Tf 0 0 0 rg (Note that the ClientSide and ServerSide will block until SHMMain is called and creates the memory pool.) Tj T* 0 Tw .044431 Tw (The ClientSide will block and wait until the the ServerSide creates the pipe. The only way this can become) Tj T* 0 Tw 1.638651 Tw (problematic if the shared memory pool has a "unclean" shutdown: if you can't guarantee SHMMain is) Tj T* 0 Tw .09881 Tw (called before all the clients and servers are created, it's important to make sure the shared memory region) Tj T* 0 Tw 2.862485 Tw (has been destroyed, otherwise the client and server may pick up the shared pool from the LAST) Tj T* 0 Tw .848735 Tw (invocation. To make sure the shared memory is clean, make sure /proc/shm does has been cleaned up) Tj T* 0 Tw 1.87881 Tw (and does NOT contain the memory pools; this is discussed a bit more in the ) Tj /F3 10 Tf (Five Major Headaches) Tj T* 0 Tw /F1 10 Tf (section below later.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 251.8236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Middleside) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 209.8236 cm
q
BT 1 0 0 1 0 26 Tm 1.123488 Tw 12 TL /F1 10 Tf 0 0 0 rg (Many times a server is also a client: it reads from one queue and posts to another queue \(like a UNIX) Tj T* 0 Tw .78186 Tw (pipeline\): this role is frequently called a ) Tj /F3 10 Tf (transformer ) Tj /F1 10 Tf (in X-Midas or M2k speak. The example below show) Tj T* 0 Tw (how to ) Tj /F3 10 Tf (both ) Tj /F1 10 Tf (read from a client and post to a server in the same process:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 80.62362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 120 re B*
Q
q
BT 1 0 0 1 0 98 Tm 12 TL /F4 10 Tf 0 0 0 rg (ClientSide client\("shm_region", "pipe_0", true\);) Tj T* (client.start\(\); // read from this pipe) Tj T* (CQ) Tj (&) Tj ( input = client.pipe\(\);) Tj T*  T* (ServerSide server\("shm_region", "pipe_1", 4, true\);) Tj T* (server.start\(\); // write to this pipe) Tj T* (CQ) Tj (&) Tj ( output = server.pipe\(\);) Tj T*  T* (while \(1\) {) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
35 0 obj
<< /Length 3699 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 607.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 156 re B*
Q
q
BT 1 0 0 1 0 134 Tm 12 TL /F4 10 Tf 0 0 0 rg  T* (    // Read from input pipe) Tj T* (    Val in_packet;) Tj T* (    if \(!input.dequeue\(.1, in_packet\)\)) Tj T* (        continue; // retry to get input) Tj T*  T* (    // Write to output pipe) Tj T* (    bool enqueued = false;) Tj T* (    while \(!enqueued\) {) Tj T* (      enqueued = out.enqueue\(in_packet, .1\);) Tj T* (    }) Tj T* (}) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 563.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 1.14856 Tw (In this way, a client and server can be used together. In fact, there is no apriori limit on the number of) Tj T* 0 Tw .107765 Tw (clients and servers that can be in a single process \(limited only by the amount of memory\). Multiple clients) Tj T* 0 Tw (and/or servers allows programming any type of semantics you want: see the new section.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 530.8236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Complex Interactions) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 452.8236 cm
q
BT 1 0 0 1 0 62 Tm .604985 Tw 12 TL /F1 10 Tf 0 0 0 rg (By default, the CQ class \(so-called because it is a Queue that preserves thread-safety using a Condition) Tj T* 0 Tw 1.129398 Tw (variable: CQ\) has a simple interface: Vals \(which exist in shared memory, this is critical!\) can either be) Tj T* 0 Tw 2.364597 Tw (enqueued or dequeued. Period. There can be any number of processes enqueueing or dequeueing) Tj T* 0 Tw 1.746457 Tw (simultaneously, but \(this is important\) ) Tj /F3 10 Tf (there is no notion of multicast) Tj /F1 10 Tf (: once a Val is dequeued by any) Tj T* 0 Tw .71881 Tw (reader, it's gone, even if there are twelve readers. If we wanted to support multicast, or any complicated) Tj T* 0 Tw (semantics for multiple readers, we have to enforce those ourselves.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 410.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL 1.157633 Tw (For example, if we wanted to have the multicast semantics to only dequeue when all the readers have) Tj T* 0 Tw .167765 Tw (read the packet \(or anything more complicated\), we could put all the logic in a simple component with one) Tj T* 0 Tw (input and multiple outputs:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 77.62362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 480 324 re B*
Q
q
BT 1 0 0 1 0 302 Tm 12 TL /F4 10 Tf 0 0 0 rg (// Implement a simple multicast with n clients where) Tj T* (// all clients see all data that is dequeued.) Tj T*  T* (// Start up the single input) Tj T* (ClientSide single_input\("shm_region", "pipe_input", true\);) Tj T* (single_input.start\(\);) Tj T* (CQ) Tj (&) Tj ( input = single_input.pipe\(\);) Tj T*  T* (// Array of outputs: each output queue will see the input exactly once) Tj T* (Array) Tj (<) Tj (ServerSide*) Tj (>) Tj ( outputs;) Tj T* (for \(int ii=0; ii) Tj (<) Tj (number_of_outputs; ii++\) {) Tj T* (   ServerSide* ssp=new ServerSide\("shm_region", "out"+Stringize\(ii\), 4, true\);) Tj T* (   ssp-) Tj (>) Tj (start\(\);) Tj T* (   outputs.append\(ssp\);) Tj T* (}) Tj T*  T* (while \(1\) {) Tj T*  T* (   // Pull input off the input queue) Tj T* (   Val in_packet;) Tj T* (   if \(!input.dequeue\(.1, in_packet\)\) {) Tj T* (      continue;  // nothing available, try again) Tj T* (   }) Tj T*  T* (   // Got input: implement multicast semantics so) Tj T* (   // all outputs see the same input) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
36 0 obj
<< /Length 5099 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 655.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 108 re B*
Q
q
BT 1 0 0 1 0 86 Tm 12 TL /F4 10 Tf 0 0 0 rg (   for \(int ii=0; ii) Tj (<) Tj (outputs.length\(\); ii++\) {) Tj T* (      ServerSide* ssp = outputs[ii];) Tj T* (      CQ) Tj (&) Tj ( out = ssp-) Tj (>) Tj (pipe\(\);) Tj T*  T* (      // Try to enqueue; blocks until delivered) Tj T* (      out.enq\(in_packet\);) Tj T* (   }) Tj T* (}) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 623.8236 cm
q
BT 1 0 0 1 0 14 Tm 1.297356 Tw 12 TL /F1 10 Tf 0 0 0 rg (With the example above, all outputs see a copy of the input. Since ) Tj /F3 10 Tf (hopefully ) Tj /F1 10 Tf (the input packet is just a) Tj T* 0 Tw (proxy \(where the underlying Tab is shared\), this should be a quick and easy dispersal.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 569.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL .179398 Tw (Although this abstraction makes it a little harder to implement multiple readers and writers, it gives you full) Tj T* 0 Tw 2.996412 Tw (mechanism to implement any policy for multiple readers. For example, in the example above, the) Tj T* 0 Tw 1.09332 Tw (multicast can get stuck if one the readers never reads its pipe: the enqueue blocks forever. What if we) Tj T* 0 Tw (wanted data to drop if the reader hadn't read it after 5 seconds?:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 488.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
BT 1 0 0 1 0 50 Tm 12 TL /F4 10 Tf 0 0 0 rg (bool enqueued = out.enqueue\(in_packet, 5.0\);) Tj T* (if \(!enqueued\) {) Tj T* (   cerr ) Tj (<) Tj (<) Tj ( "Reader " ) Tj (<) Tj (<) Tj ( ii " ) Tj (<) Tj (<) Tj ( is too slow, dropping packet" ) Tj (<) Tj (<) Tj ( endl;) Tj T* (   continue;) Tj T* (}) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 420.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 50 Tm /F1 10 Tf 12 TL 1.569269 Tw (Thus with a simple change, we have implemented a custom multi-cast semantics. For systems where) Tj T* 0 Tw .350651 Tw (dropped data is okay, we can implement whatever semantics we need with whatever time constraints are) Tj T* 0 Tw .506098 Tw (relevant. If dropped data is not okay, we can keep retrying to send data, with some messages. We could) Tj T* 0 Tw .567356 Tw (also implement a nice GUI to show the status of a pipe. Whatever is needed can be built on ServerSide,) Tj T* 0 Tw (ClientSide and timeouts.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 390.6236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Address Randomization) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 324.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 50 Tm /F1 10 Tf 12 TL 2.254147 Tw (Many Linuxes today implement the Address Randomization "feature" to stop hackers from exploiting) Tj T* 0 Tw .56881 Tw (address space regularity. In other words, the code and data part of your program can be randomly place) Tj T* 0 Tw 1.509318 Tw ("anywhere" in main memory. This can be problematic for systems where shared memory needs to be) Tj T* 0 Tw .948409 Tw (mapped in: What if regions conflict? What part of memory is used? To that end, you may have to force) Tj T* 0 Tw (your processes to turn off this feature. This feature can be turned off on a per-process basis easily:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 267.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 48 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F4 10 Tf 12 TL (% setarch i386 -L -R serverside_ex ...    # 32-bit machine) Tj T* (       or) Tj T* (% setarch x86_64 -L -R serverside_ex ...  # 64-bit machine) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 235.4236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .15436 Tw (Frequently, the simple examples work without the above, but the more complex programs may need to do) Tj T* 0 Tw (the above. Note that the examples remind you to use setarch when you run them.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 205.4236 cm
q
BT 1 0 0 1 0 14 Tm .814987 Tw 12 TL /F1 10 Tf 0 0 0 rg (If you forget to turn off the feature, then each of the SHMMain, ClientSide and ServerSide will ) Tj /F3 10 Tf (warn ) Tj /F1 10 Tf (you) Tj T* 0 Tw (with a large message to standard error:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 88.22362 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 108 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 86 Tm /F4 10 Tf 12 TL (% serverside_ex ...   # forgot to run with setarch!) Tj T*  T* (!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!) Tj T* (! It appears that the address randomization feature is still on.) Tj T* (! Your SHMMain/ServerSide/ClientSide is unlikely to work correctly.) Tj T* (! Program will continue running ... but may not run correctly ...) Tj T* (!) Tj T* (! Make sure the process that's gets started up has this feature) Tj T* ET
Q
Q
Q
Q
Q
 
endstream
endobj
37 0 obj
<< /Length 5909 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 691.8236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 72 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 50 Tm /F4 10 Tf 12 TL (! turned off using setarch.  For example:) Tj T* (!  % setarch i386 -L -R startup_program     # 32-bit machine) Tj T* (!           or) Tj T* (!  % setarch x86_64 -L -R startup_program   # 64-bit machine) Tj T* (!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 635.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL .536457 Tw (Detecting the absence of the Address Randomization feature is a bit tricky, so you may be using setarch) Tj T* 0 Tw .81561 Tw (correctly but it still outputs the warning. Lots of false positive warning messages are clumsy and messy,) Tj T* 0 Tw 2.019987 Tw (so there is a mechanism to turn off the potential warning. For example, to turn off this message for) Tj T* 0 Tw (SHMMain:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 578.6236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 48 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F4 10 Tf 12 TL (SHMMain mem\(...\);) Tj T* (mem.warning\(false\);  // Turn off warning message above) Tj T* (mem.start\(\);         // Warning message above suppressed) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 522.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL .665868 Tw (Both ClientSide and ServerSide have the same method. By default, the warning is turned on: the idea is) Tj T* 0 Tw 1.316988 Tw (that it is better to get a warning message when you are first starting so you can figure out how things) Tj T* 0 Tw 1.039985 Tw (work; Once you are comfortable and always turning on the setarch feature, you don't need the warning) Tj T* 0 Tw (anymore and can turn it off if needed.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 492.6236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Examples) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 462.6236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 3.725814 Tw (There are three standalone examples and three X-Midas examples in the PicklingTools baseline) Tj T* 0 Tw (demonstrating the shared mem client/server tools.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 432.6236 cm
q
BT 1 0 0 1 0 14 Tm 2.346342 Tw 12 TL /F1 10 Tf 0 0 0 rg (In the C++ area are serverside_ex.cc, middleside_ex.cc and clientside_ex.cc examples. These three) Tj T* 0 Tw (examples should be run together ) Tj /F3 10 Tf (on the same machine) Tj /F1 10 Tf (:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 387.4236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F4 10 Tf 12 TL (# In one shell prompt) Tj T* (% setarch i386 -L -R serverside_ex mempool 1000000 pipe1 4) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 355.4236 cm
q
BT 1 0 0 1 0 14 Tm .029983 Tw 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F4 10 Tf 0 0 0 rg (serverside_ex ) Tj /F1 10 Tf 0 0 0 rg (creates the shared memory region \(called ) Tj /F4 10 Tf 0 0 0 rg (mempool) Tj /F1 10 Tf 0 0 0 rg (\) of one million bytes. The pipe) Tj T* 0 Tw (the server will write to is ) Tj /F4 10 Tf 0 0 0 rg (pipe1 ) Tj /F1 10 Tf 0 0 0 rg (and it will have a capacity of four packets:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 310.2236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F4 10 Tf 12 TL (# In another shell prompt) Tj T* (% setarch i386 -L -R middleside_ex mempool pipe1 pipe2 4) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 278.2236 cm
q
BT 1 0 0 1 0 14 Tm .769318 Tw 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F4 10 Tf 0 0 0 rg (middleside_ex ) Tj /F1 10 Tf 0 0 0 rg (waits for the shared memory region \(called ) Tj /F4 10 Tf 0 0 0 rg (mempool) Tj /F1 10 Tf 0 0 0 rg (\) to be available. Once it is,) Tj T* 0 Tw (the middleside reads from ) Tj /F4 10 Tf 0 0 0 rg (pipe1 ) Tj /F1 10 Tf 0 0 0 rg (and writes to ) Tj /F4 10 Tf 0 0 0 rg (pipe2) Tj /F1 10 Tf 0 0 0 rg (; ) Tj /F4 10 Tf 0 0 0 rg (pipe2 ) Tj /F1 10 Tf 0 0 0 rg (also has a capacity of four packets:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 233.0236 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 468.6898 36 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F4 10 Tf 12 TL (# In yet another shell prompt) Tj T* (% setarch i386 -L -R clientside_ex mempool pipe2) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 62.69291 201.0236 cm
q
BT 1 0 0 1 0 14 Tm 1.835984 Tw 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F4 10 Tf 0 0 0 rg (clientside_ex ) Tj /F1 10 Tf 0 0 0 rg (waits for the memory pool, waits from ) Tj /F4 10 Tf 0 0 0 rg (pipe2 ) Tj /F1 10 Tf 0 0 0 rg (to be created, then reads from) Tj T* 0 Tw /F4 10 Tf 0 0 0 rg (pipe2) Tj /F1 10 Tf 0 0 0 rg (.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 171.0236 cm
q
BT 1 0 0 1 0 14 Tm .402488 Tw 12 TL /F1 10 Tf 0 0 0 rg (This will cause the server to talk the middle and the middle will talk to the final client. Note that SHMMain) Tj T* 0 Tw (is created ) Tj /F3 10 Tf (exactly once ) Tj /F1 10 Tf (by serverside_ex.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 153.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Also note that the X-Midas primitives can talk to the standalone executables.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 123.0236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Five Biggest Headaches) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 105.0236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (The five biggest problems getting shared memory across platforms to work are:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 99.02362 cm
Q
q
1 0 0 1 62.69291 99.02362 cm
Q
 
endstream
endobj
38 0 obj
<< /Length 6561 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 729.0236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 21 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (1.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .966651 Tw (Memory size: Most Linuxes are constrained by how much shared memory they can allocate. If the) Tj T* 0 Tw .168221 Tw (allocation is too big, then Linux will simply fail. Carefully try larger and larger sizes of shared memory) Tj T* 0 Tw (from SHMMain to make sure that your box can legally create and use that much shared memory.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 723.0236 cm
Q
q
1 0 0 1 62.69291 519.8236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 188.2 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (2.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 164.2 cm
q
BT 1 0 0 1 0 26 Tm .68881 Tw 12 TL /F1 10 Tf 0 0 0 rg (Using Vals in shared memory. Once a Val is created in shared memory, most updates on the table) Tj T* 0 Tw .494987 Tw (will cause the new keys/values to be created in the same shared memory. If you wish to enqueue a) Tj T* 0 Tw (table or Array, make ) Tj /F3 10 Tf (sure ) Tj /F1 10 Tf (the entire table is in shared memory:) Tj T* ET
Q
Q
q
1 0 0 1 23 59 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 445.6898 96 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 74 Tm /F4 10 Tf 12 TL (// Okay) Tj T* (Val data = Shared\(shm, Tab\(\)\);  // created in shared memory) Tj T* (pipe.enqueue\(data\);             // Okay, because data in shared memory) Tj T*  T* (// !!!! NOT OKAY!!!) Tj T* (Val data2 = Tab\(\);  // data2 NOT in shared memory!!) Tj T* (pipe.enqueue\(data2\);  // Will seg fault) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 38 Tm .122485 Tw 12 TL /F1 10 Tf 0 0 0 rg (There is a routine called ) Tj /F4 10 Tf 0 0 0 rg (IsSHM ) Tj /F1 10 Tf 0 0 0 rg (from #include "checkshm.h" which allows the user to check and see) Tj T* 0 Tw .618876 Tw (if a Val is completely contained in shared memory. In debug mode, this is a very useful tool; before) Tj T* 0 Tw .789461 Tw (data is enqueued on a shared memory pipe, the table can be checked to make sure all of its parts) Tj T* 0 Tw (are in shared memory.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 513.8236 cm
Q
q
1 0 0 1 62.69291 244.6236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 254.2 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (3.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 206.2 cm
q
0 0 0 rg
BT 1 0 0 1 0 50 Tm /F1 10 Tf 12 TL 1.14811 Tw (Left-Over files. By default, the shared memory regions have an file in the /dev/shm area. There is) Tj T* 0 Tw .832765 Tw (good news and bad news about this. If you do not destruct SHMMain \(in the C++ sense\), then the) Tj T* 0 Tw .891318 Tw (region persists. This can be good because your queues can persist across time: assuming a client) Tj T* 0 Tw 1.558651 Tw (connect and disconnects frequently, this can just work as the new connection will simply pick up) Tj T* 0 Tw (where the last one left off.) Tj T* ET
Q
Q
q
1 0 0 1 23 188.2 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (This can be horrible if the queues get into an inconsistent state: then every client will simply break.) Tj T* ET
Q
Q
q
1 0 0 1 23 158.2 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .799985 Tw (It can be useful to completely clean /dev/shm of your shared memory. By default, when you create) Tj T* 0 Tw (shared memory region like the "shm_region" in all the examples above, two files are created:) Tj T* ET
Q
Q
q
1 0 0 1 23 113 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 445.6898 36 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F4 10 Tf 12 TL (/dev/shm/shm_region_boot) Tj T* (/dev/shm/shm_region) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 23 51 cm
q
0 0 0 rg
BT 1 0 0 1 0 38 Tm /F1 10 Tf 12 TL .19881 Tw (The boot region is very small and used only to pass global information to each client \(where memory) Tj T* 0 Tw .322093 Tw (should be mapped, the size of the memory, where to find the pipes, etc\). The boot is first mapped in) Tj T* 0 Tw .394104 Tw (anywhere in memory. The data in the boot informs where to map the main section: the main section) Tj T* 0 Tw (contains the giant memory pool.) Tj T* ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 38 Tm 6.91152 Tw 12 TL /F1 10 Tf 0 0 0 rg (To make sure your application starts in a fresh start, it's probably worth removing) Tj T* 0 Tw 2.227109 Tw /F4 10 Tf 0 0 0 rg (/dev/shm/shm_region_boot ) Tj /F1 10 Tf 0 0 0 rg (and ) Tj /F4 10 Tf 0 0 0 rg (/dev/shm/shm_region ) Tj /F1 10 Tf 0 0 0 rg (before starting, or restarting your) Tj T* 0 Tw 1.431412 Tw (application. Note that ) Tj /F3 10 Tf (by default) Tj /F1 10 Tf (, SHMMain will completely clean-up for you when you create and) Tj T* 0 Tw (start the SHMMain component.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 238.6236 cm
Q
q
1 0 0 1 62.69291 125.4236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 98.2 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (4.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 98.2 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Forgetting About Address Randomization) Tj T* ET
Q
Q
q
1 0 0 1 23 56.2 cm
q
0 0 0 rg
BT 1 0 0 1 0 26 Tm /F1 10 Tf 12 TL .517674 Tw (Frustratingly, sometimes things will work with the address randomization on, then one small change) Tj T* 0 Tw .14332 Tw (will cause everything to stop working. It's best put this as part of a start-up script where all processes) Tj T* 0 Tw (will "inherit" this attribute:) Tj T* ET
Q
Q
q
1 0 0 1 23 23 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 445.6898 24 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F4 10 Tf 12 TL (% setarch i386 -L -R startup_process) Tj T* ET
Q
Q
Q
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 2 Tm 12 TL /F1 10 Tf 0 0 0 rg (See the ) Tj /F3 10 Tf (Address Randomization ) Tj /F1 10 Tf (section above.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 119.4236 cm
Q
q
1 0 0 1 62.69291 107.4236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 -3 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (5.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (Holding On Too Long or Letting Go Too Soon) Tj T* ET
Q
Q
q
Q
Q
 
endstream
endobj
39 0 obj
<< /Length 3647 >>
stream
1 0 0 1 0 0 cm  BT /F1 12 Tf 14.4 TL ET
q
1 0 0 1 62.69291 575.8236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 6 176.2 Tm  T* ET
q
1 0 0 1 23 150.2 cm
q
BT 1 0 0 1 0 26 Tm 2.63998 Tw 12 TL /F1 10 Tf 0 0 0 rg (What does ) Tj /F4 10 Tf 0 0 0 rg (Shared\(client.pool\(\),) Tj ( ) Tj (Tab\(\)\) ) Tj /F1 10 Tf 0 0 0 rg (return? A proxy to a Tab in shared memory) Tj T* 0 Tw 1.24229 Tw (protected by a process-safe reference count. Remember, that every copy of the proxy increments) Tj T* 0 Tw (the reference count:) Tj T* ET
Q
Q
q
1 0 0 1 23 -3 cm
q
q
1 0 0 1 0 0 cm
q
1 0 0 1 6.6 6.6 cm
q
.662745 .662745 .662745 RG
.5 w
.960784 .960784 .862745 rg
n -6 -6 445.6898 144 re B*
Q
q
0 0 0 rg
BT 1 0 0 1 0 122 Tm /F4 10 Tf 12 TL (// Serverside) Tj T* ({) Tj T* (  Val v = Shared\(shm, Tab\(\)\);  // ref count at 1) Tj T* (  pipe.enq\(v\);                 // ref count at 2) Tj T* (} // Val destructed, ref count at 1) Tj T*  T*  T* (// Clientside) Tj T* ({) Tj T* (  Val off = pipe.deq\(\);  // Ref count at 1) Tj T* (}  // Val destructed, ref count at 0, memory reclaimed) Tj T* ET
Q
Q
Q
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 575.8236 cm
Q
q
1 0 0 1 62.69291 569.8236 cm
Q
q
1 0 0 1 62.69291 515.8236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
BT 1 0 0 1 0 2 Tm  T* ET
q
1 0 0 1 20 30 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.70832 Tw (Thus, once you have enqueued your shared Tab, you can let go of the packet and let the client) Tj T* 0 Tw (dequeue it. Once the client dequeues it and is done, it will be reclaimed by the pool.) Tj T* ET
Q
Q
q
1 0 0 1 20 0 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL 1.092765 Tw (Be careful not to keep your Tab alive after you have enqueued it, or that could become a memory) Tj T* 0 Tw (growth.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 515.8236 cm
Q
q
1 0 0 1 62.69291 482.8236 cm
q
BT 1 0 0 1 0 3.5 Tm 21 TL /F2 17.5 Tf 0 0 0 rg (Conclusion) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 464.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL (With three simple abstractions, tables across shared memory can be much easier to manipulate.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 434.8236 cm
q
BT 1 0 0 1 0 3 Tm 18 TL /F2 15 Tf 0 0 0 rg (Known Bugs:) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 404.8236 cm
q
0 0 0 rg
BT 1 0 0 1 0 14 Tm /F1 10 Tf 12 TL .233988 Tw (There are still some known bugs: we prefer to release early so as to get feedback, even if there are some) Tj T* 0 Tw (known issues.) Tj T* ET
Q
Q
q
1 0 0 1 62.69291 398.8236 cm
Q
q
1 0 0 1 62.69291 398.8236 cm
Q
q
1 0 0 1 62.69291 374.8236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 9 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (1.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 14 Tm .027045 Tw 12 TL /F1 10 Tf 0 0 0 rg (The ) Tj /F4 10 Tf 0 0 0 rg (int_un ) Tj /F1 10 Tf 0 0 0 rg (and ) Tj /F4 10 Tf 0 0 0 rg (int_n ) Tj /F1 10 Tf 0 0 0 rg (DO NOT work with shared memory. A future version will fix this. ) Tj /F2 10 Tf (FIXED: in) Tj T* 0 Tw (PicklingTools 1.4.1) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 368.8236 cm
Q
q
1 0 0 1 62.69291 344.8236 cm
0 0 0 rg
BT /F1 10 Tf 12 TL ET
q
1 0 0 1 6 9 cm
q
0 0 0 rg
BT 1 0 0 1 0 2 Tm /F1 10 Tf 12 TL 5.66 0 Td (2.) Tj T* -5.66 0 Td ET
Q
Q
q
1 0 0 1 23 -3 cm
q
BT 1 0 0 1 0 14 Tm 1.017485 Tw 12 TL /F1 10 Tf 0 0 0 rg (Should a Val initialized from a Proxy copy the allocator? This makes the ) Tj /F4 10 Tf 0 0 0 rg (IsSHM ) Tj /F1 10 Tf 0 0 0 rg (check without an) Tj T* 0 Tw (explicit work-around for Proxies.) Tj T* ET
Q
Q
q
Q
Q
q
1 0 0 1 62.69291 344.8236 cm
Q
 
endstream
endobj
40 0 obj
<< /Nums [ 0 41 0 R 1 42 0 R 2 43 0 R 3 44 0 R 4 45 0 R 
  5 46 0 R 6 47 0 R 7 48 0 R 8 49 0 R ] >>
endobj
41 0 obj
<< /S /D /St 1 >>
endobj
42 0 obj
<< /S /D /St 2 >>
endobj
43 0 obj
<< /S /D /St 3 >>
endobj
44 0 obj
<< /S /D /St 4 >>
endobj
45 0 obj
<< /S /D /St 5 >>
endobj
46 0 obj
<< /S /D /St 6 >>
endobj
47 0 obj
<< /S /D /St 7 >>
endobj
48 0 obj
<< /S /D /St 8 >>
endobj
49 0 obj
<< /S /D /St 9 >>
endobj
xref
0 50
0000000000 65535 f
0000000075 00000 n
0000000139 00000 n
0000000249 00000 n
0000000364 00000 n
0000000482 00000 n
0000000590 00000 n
0000000799 00000 n
0000001008 00000 n
0000001217 00000 n
0000001426 00000 n
0000001636 00000 n
0000001846 00000 n
0000002056 00000 n
0000002266 00000 n
0000002476 00000 n
0000002585 00000 n
0000002833 00000 n
0000002911 00000 n
0000003023 00000 n
0000003214 00000 n
0000003325 00000 n
0000003452 00000 n
0000003579 00000 n
0000003693 00000 n
0000003871 00000 n
0000003997 00000 n
0000004123 00000 n
0000004250 00000 n
0000004405 00000 n
0000004508 00000 n
0000004624 00000 n
0000010035 00000 n
0000015273 00000 n
0000019850 00000 n
0000024349 00000 n
0000028105 00000 n
0000033261 00000 n
0000039227 00000 n
0000045845 00000 n
0000049549 00000 n
0000049669 00000 n
0000049706 00000 n
0000049743 00000 n
0000049780 00000 n
0000049817 00000 n
0000049854 00000 n
0000049891 00000 n
0000049928 00000 n
0000049965 00000 n
trailer
<< /ID 
 % ReportLab generated PDF document -- digest (http://www.reportlab.com)
 [(\304\201\016\370\322\374\326=C\265\222\362\315\364\273.) (\304\201\016\370\322\374\326=C\265\222\362\315\364\273.)]
 /Info 16 0 R /Root 15 0 R /Size 50 >>
startxref
50002
%%EOF
